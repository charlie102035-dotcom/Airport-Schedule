<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Running</title>
    <link rel="icon" href="/static/favicon.png" />
    <link rel="stylesheet" href="/static/app.css?v=20260210r" />
  </head>
  <body class="home-page app-page running-page">
    <div class="geo-bg" aria-hidden="true">
      <span class="geo-line geo-line-a"></span>
      <span class="geo-line geo-line-b"></span>
      <span class="geo-line geo-line-c"></span>
      <span class="geo-line geo-line-d"></span>
      <span class="geo-line geo-line-e"></span>
      <span class="geo-poly geo-poly-a"></span>
      <span class="geo-poly geo-poly-b"></span>
      <span class="geo-poly geo-poly-c"></span>
      <span class="geo-poly geo-poly-d"></span>
      <span class="geo-poly geo-poly-e"></span>
      <span class="geo-poly geo-poly-f"></span>
      <span class="geo-poly geo-poly-g"></span>
      <span class="geo-poly geo-poly-h"></span>
      <span class="geo-poly geo-poly-i"></span>
    </div>

    <div class="container home-shell app-shell">
      <main class="home-layout">
        <section class="home-form-card app-card">
          <header class="app-header">
            <div>
              <div class="hero-kicker">TSA SHIFT ENGINE</div>
              <h1 class="app-title">Running</h1>
              <p class="lead app-subtitle">目前任務：{{ mode_label }}</p>
            </div>
            <a class="btn" href="/monthly">回首頁</a>
          </header>

          <div class="app-progress-card">
            <div class="progress-wrap progress-wrap-animated">
              <div id="progressBar" class="progress-bar progress-bar-live"></div>
            </div>
            <div id="progressText" class="progress-meta"></div>
            <div id="phaseBoard" class="run-phase-board" hidden>
              <div class="run-phase-step" data-phase="prepare">
                <span class="run-phase-dot"></span>
                <span class="run-phase-label">資料驗證</span>
              </div>
              <div class="run-phase-step" data-phase="model">
                <span class="run-phase-dot"></span>
                <span class="run-phase-label">建立模型</span>
              </div>
              <div class="run-phase-step" data-phase="solve">
                <span class="run-phase-dot"></span>
                <span class="run-phase-label">求解中</span>
              </div>
              <div class="run-phase-step" data-phase="export">
                <span class="run-phase-dot"></span>
                <span class="run-phase-label">輸出結果</span>
              </div>
              <div class="run-phase-step" data-phase="done">
                <span class="run-phase-dot"></span>
                <span class="run-phase-label">完成</span>
              </div>
            </div>
            <div id="errorText" class="error error-box"></div>
          </div>
        </section>
      </main>
    </div>

    <script>
      const navEntry = (performance.getEntriesByType && performance.getEntriesByType('navigation')[0]) || null;
      if (navEntry && navEntry.type === 'reload') {
        window.location.replace('/monthly');
      }

      const token = '{{ token }}';
      const modeKey = '{{ mode_key }}';
      const isDeparture = modeKey === 'departure';
      const bar = document.getElementById('progressBar');
      const txt = document.getElementById('progressText');
      const phaseBoard = document.getElementById('phaseBoard');
      const err = document.getElementById('errorText');
      const phaseSteps = Array.from(document.querySelectorAll('.run-phase-step'));
      const phaseOrder = ['prepare', 'model', 'solve', 'export', 'done'];
      const phaseLabelMap = {
        prepare: '資料驗證',
        model: '建立模型',
        solve: '求解中',
        export: '輸出結果',
        done: '完成',
        error: '失敗',
      };

      let backendPct = 0;
      let targetPct = 0;
      let shownPct = 0;
      let etaSec = null;
      let elapsedSec = 0;
      let currentPhase = 'prepare';
      let donePending = false;
      let failed = false;
      let redirecting = false;
      let lastFrameTs = performance.now();

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function showError(message) {
        err.textContent = message;
        err.classList.add('show');
      }

      function clearError() {
        err.textContent = '';
        err.classList.remove('show');
      }

      function formatElapsed(seconds) {
        const total = Math.max(0, Math.floor(Number(seconds) || 0));
        const hh = Math.floor(total / 3600);
        const mm = Math.floor((total % 3600) / 60);
        const ss = total % 60;
        if (hh > 0) {
          return String(hh).padStart(2, '0') + ':' + String(mm).padStart(2, '0') + ':' + String(ss).padStart(2, '0');
        }
        return String(mm).padStart(2, '0') + ':' + String(ss).padStart(2, '0');
      }

      function updatePhaseBoard() {
        if (!isDeparture || !phaseBoard) return;
        const activeIdx = Math.max(0, phaseOrder.indexOf(currentPhase));
        phaseSteps.forEach((el) => {
          el.classList.remove('is-active', 'is-complete');
          const key = el.dataset.phase || '';
          const idx = phaseOrder.indexOf(key);
          if (idx >= 0 && idx < activeIdx) el.classList.add('is-complete');
          if (idx === activeIdx) el.classList.add('is-active');
        });
      }

      function ingestProgress(data) {
        const rawPct = clamp((Number(data.progress) || 0) * 100, 0, 100);
        backendPct = Math.max(backendPct, rawPct);
        elapsedSec = Math.max(elapsedSec, Number(data.elapsed_sec) || 0);
        if (typeof data.phase === 'string' && data.phase.trim()) {
          currentPhase = data.phase.trim();
        }

        const nextEta = Number(data.eta_sec);
        etaSec = (!isDeparture && Number.isFinite(nextEta)) ? Math.max(0, nextEta) : null;

        if (data.status === 'done') {
          donePending = true;
          currentPhase = 'done';
          targetPct = 100;
          etaSec = null;
          return;
        }
        targetPct = Math.max(targetPct, Math.min(99.4, backendPct));
      }

      function renderMeta() {
        const pct = Math.floor(shownPct);
        if (isDeparture) {
          const phaseLabel = phaseLabelMap[currentPhase] || '執行中';
          const finishingText = donePending && shownPct < 99.6 ? ' | 即將完成' : '';
          txt.textContent = '階段：' + phaseLabel + ' | 已耗時 ' + formatElapsed(elapsedSec) + finishingText;
          updatePhaseBoard();
          return;
        }
        let etaText = '';
        if (etaSec !== null && !donePending) {
          const total = Math.max(0, Math.floor(etaSec));
          const mm = Math.floor(total / 60);
          const ss = total % 60;
          etaText = ' | ETA ' + mm + 'm ' + ss + 's';
        }
        const finishingText = donePending && shownPct < 99.6 ? ' | finishing...' : '';
        txt.textContent = 'Progress ' + pct + '%' + etaText + finishingText;
      }

      function animateProgress(ts) {
        const dt = Math.min(80, Math.max(8, ts - lastFrameTs));
        lastFrameTs = ts;
        const gap = targetPct - shownPct;

        if (gap > 0.02) {
          const speed = donePending
            ? Math.max(120, gap * 9.5)
            : Math.max(16, Math.min(70, 9 + gap * 3.6));
          shownPct = Math.min(targetPct, shownPct + (speed * dt) / 1000);
          bar.style.width = shownPct.toFixed(2) + '%';
        }

        renderMeta();

        if (donePending && shownPct >= 99.6 && !redirecting) {
          redirecting = true;
          window.location.href = '/preview/' + token;
          return;
        }
        requestAnimationFrame(animateProgress);
      }

      async function poll() {
        if (failed || redirecting) return;
        try {
          const resp = await fetch('/progress/' + token, { cache: 'no-store' });
          const data = await resp.json();
          if (!resp.ok || data.status === 'error') {
            failed = true;
            showError(data.message || 'Run failed.');
            return;
          }
          clearError();
          ingestProgress(data);
        } catch (e) {
          showError('連線不穩，正在重試...');
        }
        setTimeout(poll, 420);
      }

      if (isDeparture && phaseBoard) {
        phaseBoard.hidden = false;
      }

      renderMeta();
      requestAnimationFrame(animateProgress);
      poll();
    </script>
  </body>
</html>
